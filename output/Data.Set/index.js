// Generated by psc version 0.8.0.0
"use strict";
var Prelude = require("Prelude");
var Data_Foldable = require("Data.Foldable");
var Data_List = require("Data.List");
var Data_Monoid = require("Data.Monoid");
var Data_Tuple = require("Data.Tuple");
var Data_Map = require("Data.Map");
var Control_Monad_Eff = require("Control.Monad.Eff");
var Control_Monad_ST = require("Control.Monad.ST");
var Control_Monad_Rec_Class = require("Control.Monad.Rec.Class");
var Data_Array = require("Data.Array");
var Data_Array_ST = require("Data.Array.ST");
var Data_Array_Unsafe = require("Data.Array.Unsafe");
var Data_Either = require("Data.Either");
var Data_Maybe = require("Data.Maybe");
var Data_Unfoldable = require("Data.Unfoldable");
var Set = (function () {
    function Set(value0) {
        this.value0 = value0;
    };
    Set.create = function (value0) {
        return new Set(value0);
    };
    return Set;
})();
var union = function (dictOrd) {
    return function (v) {
        return function (v1) {
            return new Set(Data_Map.union(dictOrd)(v.value0)(v1.value0));
        };
    };
};
var toList = function (v) {
    return Prelude.map(Data_List.functorList)(Data_Tuple.fst)(Data_Map.toList(v.value0));
};
var toArray = function (dictOrd) {
    return function ($57) {
        return Data_List.fromList(Data_Unfoldable.unfoldableArray)(toList($57));
    };
};
var size = function (v) {
    return Data_Map.size(v.value0);
};
var singleton = function (a) {
    return new Set(Data_Map.singleton(a)(Prelude.unit));
};
var showSet = function (dictShow) {
    return new Prelude.Show(function (s) {
        return "fromList " + Prelude.show(Data_List.showList(dictShow))(toList(s));
    });
};
var semigroupSet = function (dictOrd) {
    return new Prelude.Semigroup(union(dictOrd));
};
var member = function (dictOrd) {
    return function (a) {
        return function (v) {
            return Data_Map.member(dictOrd)(a)(v.value0);
        };
    };
};
var isEmpty = function (v) {
    return Data_Map.isEmpty(v.value0);
};
var insert = function (dictOrd) {
    return function (a) {
        return function (v) {
            return new Set(Data_Map.insert(dictOrd)(a)(Prelude.unit)(v.value0));
        };
    };
};
var foldableSet = new Data_Foldable.Foldable(function (dictMonoid) {
    return function (f) {
        return function ($58) {
            return Data_Foldable.foldMap(Data_List.foldableList)(dictMonoid)(f)(toList($58));
        };
    };
}, function (f) {
    return function (x) {
        return function ($59) {
            return Data_Foldable.foldl(Data_List.foldableList)(f)(x)(toList($59));
        };
    };
}, function (f) {
    return function (x) {
        return function ($60) {
            return Data_Foldable.foldr(Data_List.foldableList)(f)(x)(toList($60));
        };
    };
});
var eqSet = function (dictEq) {
    return new Prelude.Eq(function (v) {
        return function (v1) {
            return Prelude["=="](Data_Map.eqMap(dictEq)(Prelude.eqUnit))(v.value0)(v1.value0);
        };
    });
};
var ordSet = function (dictOrd) {
    return new Prelude.Ord(function () {
        return eqSet(dictOrd["__superclass_Prelude.Eq_0"]());
    }, function (s1) {
        return function (s2) {
            return Prelude.compare(Data_List.ordList(dictOrd))(toList(s1))(toList(s2));
        };
    });
};
var empty = new Set(Data_Map.empty);
var fromFoldable = function (dictFoldable) {
    return function (dictOrd) {
        return Data_Foldable.foldl(dictFoldable)(function (m) {
            return function (a) {
                return insert(dictOrd)(a)(m);
            };
        })(empty);
    };
};
var fromList = function (dictOrd) {
    return fromFoldable(Data_List.foldableList)(dictOrd);
};
var intersection = function (dictOrd) {
    return function (s1) {
        return function (s2) {
            var rs = toArray(dictOrd)(s2);
            var rl = Data_Array.length(rs);
            var ls = toArray(dictOrd)(s1);
            var ll = Data_Array.length(ls);
            var intersect = function (acc) {
                var go = function (l) {
                    return function (r) {
                        var $50 = l < ll && r < rl;
                        if ($50) {
                            var $51 = Prelude.compare(dictOrd)(ls[l])(rs[r]);
                            if ($51 instanceof Prelude.EQ) {
                                return function __do() {
                                    Data_Array_ST.pushSTArray(acc)(ls[l])();
                                    return new Data_Either.Left({
                                        a: l + 1 | 0, 
                                        b: r + 1 | 0
                                    });
                                };
                            };
                            if ($51 instanceof Prelude.LT) {
                                return Prelude.pure(Control_Monad_Eff.applicativeEff)(new Data_Either.Left({
                                    a: l + 1 | 0, 
                                    b: r
                                }));
                            };
                            if ($51 instanceof Prelude.GT) {
                                return Prelude.pure(Control_Monad_Eff.applicativeEff)(new Data_Either.Left({
                                    a: l, 
                                    b: r + 1 | 0
                                }));
                            };
                            throw new Error("Failed pattern match: " + [ $51.constructor.name ]);
                        };
                        if (!$50) {
                            return Prelude.pure(Control_Monad_Eff.applicativeEff)(new Data_Either.Right(acc));
                        };
                        throw new Error("Failed pattern match at Data.Set line 149, column 5 - line 159, column 1: " + [ $50.constructor.name ]);
                    };
                };
                return Control_Monad_Rec_Class.tailRecM2(Control_Monad_Rec_Class.monadRecEff)(go)(0)(0);
            };
            return fromFoldable(Data_Foldable.foldableArray)(dictOrd)(Control_Monad_Eff.runPure(Data_Array_ST.runSTArray(Prelude[">>="](Control_Monad_Eff.bindEff)(Data_Array_ST.emptySTArray)(intersect))));
        };
    };
};
var monoidSet = function (dictOrd) {
    return new Data_Monoid.Monoid(function () {
        return semigroupSet(dictOrd);
    }, empty);
};
var unions = function (dictOrd) {
    return Data_Foldable.foldl(Data_List.foldableList)(union(dictOrd))(empty);
};
var $$delete = function (dictOrd) {
    return function (a) {
        return function (v) {
            return new Set(Data_Map["delete"](dictOrd)(a)(v.value0));
        };
    };
};
var difference = function (dictOrd) {
    return function (s1) {
        return function (s2) {
            return Data_Foldable.foldl(Data_List.foldableList)(Prelude.flip($$delete(dictOrd)))(s1)(toList(s2));
        };
    };
};
var subset = function (dictOrd) {
    return function (s1) {
        return function (s2) {
            return isEmpty(difference(dictOrd)(s1)(s2));
        };
    };
};
var properSubset = function (dictOrd) {
    return function (s1) {
        return function (s2) {
            return subset(dictOrd)(s1)(s2) && Prelude["/="](eqSet(dictOrd["__superclass_Prelude.Eq_0"]()))(s1)(s2);
        };
    };
};
var checkValid = function (v) {
    return Data_Map.checkValid(v.value0);
};
module.exports = {
    intersection: intersection, 
    properSubset: properSubset, 
    subset: subset, 
    difference: difference, 
    unions: unions, 
    union: union, 
    size: size, 
    fromList: fromList, 
    toList: toList, 
    fromFoldable: fromFoldable, 
    "delete": $$delete, 
    member: member, 
    insert: insert, 
    checkValid: checkValid, 
    singleton: singleton, 
    isEmpty: isEmpty, 
    empty: empty, 
    eqSet: eqSet, 
    showSet: showSet, 
    ordSet: ordSet, 
    monoidSet: monoidSet, 
    semigroupSet: semigroupSet, 
    foldableSet: foldableSet
};
