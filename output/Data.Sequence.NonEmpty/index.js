// Generated by psc version 0.8.0.0
"use strict";
var Prelude = require("Prelude");
var Control_Alt = require("Control.Alt");
var Data_Foldable = require("Data.Foldable");
var Data_Maybe = require("Data.Maybe");
var Data_Maybe_Unsafe = require("Data.Maybe.Unsafe");
var Data_Traversable = require("Data.Traversable");
var Data_Tuple = require("Data.Tuple");
var Data_Unfoldable = require("Data.Unfoldable");
var Data_Sequence = require("Data.Sequence");
var Seq = (function () {
    function Seq(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Seq.create = function (value0) {
        return function (value1) {
            return new Seq(value0, value1);
        };
    };
    return Seq;
})();
var unsnoc = function (v) {
    var $34 = Data_Sequence.unsnoc(v.value1);
    if ($34 instanceof Data_Maybe.Nothing) {
        return new Data_Tuple.Tuple(Data_Sequence.empty, v.value0);
    };
    if ($34 instanceof Data_Maybe.Just) {
        return new Data_Tuple.Tuple(Data_Sequence.cons(v.value0)($34.value0.value0), $34.value0.value1);
    };
    throw new Error("Failed pattern match at Data.Sequence.NonEmpty line 94, column 1 - line 95, column 1: " + [ $34.constructor.name ]);
};
var uncons = function (v) {
    return new Data_Tuple.Tuple(v.value0, v.value1);
};
var toPlain = function (v) {
    return Data_Sequence.cons(v.value0)(v.value1);
};
var take = function (i) {
    return function ($115) {
        return Data_Sequence.take(i)(toPlain($115));
    };
};
var tail = function (v) {
    return v.value1;
};
var splitAt = function (i) {
    return function ($116) {
        return Data_Sequence.splitAt(i)(toPlain($116));
    };
};
var snoc = function (v) {
    return function (y) {
        return new Seq(v.value0, Data_Sequence.snoc(v.value1)(y));
    };
};
var singleton = function (x) {
    return new Seq(x, Data_Sequence.empty);
};
var showSeq = function (dictShow) {
    return new Prelude.Show(function (v) {
        return "(Seq " + (Prelude.show(dictShow)(v.value0) + (" " + (Prelude.show(Data_Sequence.showSeq(dictShow))(v.value1) + ")")));
    });
};
var semigroupSeq = new Prelude.Semigroup(function (v) {
    return function (v1) {
        return new Seq(v.value0, Prelude["<>"](Data_Sequence.semigroupSeq)(Data_Sequence.snoc(v.value1)(v1.value0))(v1.value1));
    };
});
var length = function (v) {
    return Data_Sequence.length(v.value1) + 1 | 0;
};
var last = function (v) {
    return Data_Maybe.maybe(v.value0)(Prelude.id(Prelude.categoryFn))(Data_Sequence.last(v.value1));
};
var init = function ($117) {
    return Data_Tuple.fst(unsnoc($117));
};
var index = function (v) {
    return function (v1) {
        if (v === 0) {
            return new Data_Maybe.Just(v1.value0);
        };
        return Data_Sequence.index(v - 1)(v1.value1);
    };
};
var inBounds = function (v) {
    return function (v1) {
        if (v === 0) {
            return true;
        };
        return Data_Sequence.inBounds(v - 1)(v1.value1);
    };
};
var head = function (v) {
    return v.value0;
};
var functorSeq = new Prelude.Functor(function (f) {
    return function (v) {
        return new Seq(f(v.value0), Prelude["<$>"](Data_Sequence.functorSeq)(f)(v.value1));
    };
});
var fromSeq = function (dictFunctor) {
    return function (dictUnfoldable) {
        return function ($118) {
            return Data_Sequence.fromSeq(dictFunctor)(dictUnfoldable)(toPlain($118));
        };
    };
};
var fromPlainUnsafe = Prelude[">>>"](Prelude.semigroupoidFn)(Data_Sequence.uncons)(Prelude[">>>"](Prelude.semigroupoidFn)(Data_Maybe_Unsafe.fromJust)(Data_Tuple.uncurry(Seq.create)));
var foldableSeq = new Data_Foldable.Foldable(function (dictMonoid) {
    return function (f) {
        return Prelude[">>>"](Prelude.semigroupoidFn)(toPlain)(Data_Foldable.foldMap(Data_Sequence.foldableSeq)(dictMonoid)(f));
    };
}, function (f) {
    return function (z) {
        return Prelude[">>>"](Prelude.semigroupoidFn)(toPlain)(Data_Foldable.foldl(Data_Sequence.foldableSeq)(f)(z));
    };
}, function (f) {
    return function (z) {
        return Prelude[">>>"](Prelude.semigroupoidFn)(toPlain)(Data_Foldable.foldr(Data_Sequence.foldableSeq)(f)(z));
    };
});
var traversableSeq = new Data_Traversable.Traversable(function () {
    return foldableSeq;
}, function () {
    return functorSeq;
}, function (dictApplicative) {
    return Prelude[">>>"](Prelude.semigroupoidFn)(toPlain)(Prelude[">>>"](Prelude.semigroupoidFn)(Data_Traversable.sequence(Data_Sequence.traversableSeq)(dictApplicative))(Prelude.map((dictApplicative["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(fromPlainUnsafe)));
}, function (dictApplicative) {
    return function (f) {
        return Prelude[">>>"](Prelude.semigroupoidFn)(toPlain)(Prelude[">>>"](Prelude.semigroupoidFn)(Data_Traversable.traverse(Data_Sequence.traversableSeq)(dictApplicative)(f))(Prelude.map((dictApplicative["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(fromPlainUnsafe)));
    };
});
var filter = function (p) {
    return function ($119) {
        return Data_Sequence.filter(p)(toPlain($119));
    };
};
var eqSeq = function (dictEq) {
    return new Prelude.Eq(function (v) {
        return function (v1) {
            return Prelude["=="](dictEq)(v.value0)(v1.value0) && Prelude["=="](Data_Sequence.eqSeq(dictEq))(v.value1)(v1.value1);
        };
    });
};
var ordSeq = function (dictOrd) {
    return new Prelude.Ord(function () {
        return eqSeq(dictOrd["__superclass_Prelude.Eq_0"]());
    }, function (v) {
        return function (v1) {
            var $93 = Prelude.compare(dictOrd)(v.value0)(v1.value0);
            if ($93 instanceof Prelude.EQ) {
                return Prelude.compare(Data_Sequence.ordSeq(dictOrd))(v.value1)(v1.value1);
            };
            return $93;
        };
    });
};
var drop = function (i) {
    return function ($120) {
        return Data_Sequence.drop(i)(toPlain($120));
    };
};
var cons = function (x) {
    return function (v) {
        return new Seq(x, Data_Sequence.cons(v.value0)(v.value1));
    };
};
var applySeq = new Prelude.Apply(function () {
    return functorSeq;
}, function (fs) {
    return function (xs) {
        return fromPlainUnsafe(Prelude["<*>"](Data_Sequence.applySeq)(toPlain(fs))(toPlain(xs)));
    };
});
var bindSeq = new Prelude.Bind(function () {
    return applySeq;
}, function (xs) {
    return function (f) {
        return fromPlainUnsafe(Prelude[">>="](Data_Sequence.bindSeq)(toPlain(xs))(function ($121) {
            return toPlain(f($121));
        }));
    };
});
var applicativeSeq = new Prelude.Applicative(function () {
    return applySeq;
}, function (x) {
    return new Seq(x, Data_Sequence.empty);
});
var monadSeq = new Prelude.Monad(function () {
    return applicativeSeq;
}, function () {
    return bindSeq;
});
var append = function (v) {
    return function (v1) {
        return new Seq(v.value0, Prelude["<>"](Data_Sequence.semigroupSeq)(Data_Sequence.snoc(v.value1)(v1.value0))(v1.value1));
    };
};
var altSeq = new Control_Alt.Alt(function () {
    return functorSeq;
}, Prelude["<>"](semigroupSeq));
var adjust = function (f) {
    return function (v) {
        return function (v1) {
            if (v === 0) {
                return new Seq(f(v1.value0), v1.value1);
            };
            return new Seq(v1.value0, Data_Sequence.adjust(f)(v - 1)(v1.value1));
        };
    };
};
var replace = function (x) {
    return adjust(Prelude["const"](x));
};
module.exports = {
    Seq: Seq, 
    fromSeq: fromSeq, 
    replace: replace, 
    adjust: adjust, 
    index: index, 
    filter: filter, 
    drop: drop, 
    take: take, 
    splitAt: splitAt, 
    toPlain: toPlain, 
    last: last, 
    init: init, 
    tail: tail, 
    head: head, 
    unsnoc: unsnoc, 
    uncons: uncons, 
    inBounds: inBounds, 
    length: length, 
    append: append, 
    snoc: snoc, 
    cons: cons, 
    singleton: singleton, 
    showSeq: showSeq, 
    eqSeq: eqSeq, 
    ordSeq: ordSeq, 
    functorSeq: functorSeq, 
    applySeq: applySeq, 
    applicativeSeq: applicativeSeq, 
    bindSeq: bindSeq, 
    monadSeq: monadSeq, 
    semigroupSeq: semigroupSeq, 
    altSeq: altSeq, 
    foldableSeq: foldableSeq, 
    traversableSeq: traversableSeq
};
